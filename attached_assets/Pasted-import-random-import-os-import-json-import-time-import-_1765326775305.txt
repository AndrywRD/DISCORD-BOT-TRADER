import random
import os
import json
import time
import asyncio
from pathlib import Path
import discord
from discord.ext import commands


# Habilita intents necess√°rios (inclui message_content para comandos prefixados)
intents = discord.Intents.default()
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix="!", intents=intents)

# Arquivos de persist√™ncia simples
DATA_DIR = Path(__file__).parent
BALANCES_FILE = DATA_DIR / "balances.json"
LAST_CLAIM_FILE = DATA_DIR / "last_claims.json"
CARDS_FILE = DATA_DIR / "cards.json"
JOIN_TIMES_FILE = DATA_DIR / "join_times.json"


def _load_json(path: Path):
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _save_json(path: Path, data):
    try:
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception:
        pass


def _load_join_times():
    return _load_json(JOIN_TIMES_FILE)


def _save_join_times(data):
    _save_json(JOIN_TIMES_FILE, data)


def get_balance(user_id: str) -> int:
    data = _load_json(BALANCES_FILE)
    return int(data.get(user_id, 0))


def add_balance(user_id: str, amount: int):
    data = _load_json(BALANCES_FILE)
    data[user_id] = int(data.get(user_id, 0)) + int(amount)
    _save_json(BALANCES_FILE, data)


def deduct_balance(user_id: str, amount: int) -> bool:
    data = _load_json(BALANCES_FILE)
    current = int(data.get(user_id, 0))
    if current < amount:
        return False
    data[user_id] = current - int(amount)
    _save_json(BALANCES_FILE, data)
    return True


def can_claim_daily(user_id: str, cooldown_seconds: int = 24 * 60 * 60):
    data = _load_json(LAST_CLAIM_FILE)
    last = float(data.get(user_id, 0))
    now = time.time()
    if now - last >= cooldown_seconds:
        return True, 0
    return False, int(cooldown_seconds - (now - last))


def set_claim_time(user_id: str):
    data = _load_json(LAST_CLAIM_FILE)
    data[user_id] = time.time()
    _save_json(LAST_CLAIM_FILE, data)


def get_user_cards(user_id: str):
    data = _load_json(CARDS_FILE)
    return data.get(user_id, [])


def add_card_to_user(user_id: str, carta: dict, raridade: str):
    data = _load_json(CARDS_FILE)
    user_cards = data.get(user_id, [])
    entry = dict(carta)
    entry["raridade"] = raridade
    user_cards.append(entry)
    data[user_id] = user_cards
    _save_json(CARDS_FILE, data)


def card_already_exists(user_id: str, carta: dict, raridade: str) -> bool:
    user_cards = get_user_cards(user_id)
    for card in user_cards:
        if (card.get("nome") == carta.get("nome") and
            card.get("ataque") == carta.get("ataque") and
            card.get("vida") == carta.get("vida") and
            card.get("raridade") == raridade):
            return True
    return False


# Probabilidades
raridades = {
    "Comum": 0.6,
    "Rara": 0.3,
    "√âpica": 0.95,
    "Lend√°ria": 0.03
}

# Emojis por raridade para deixar os embeds mais bonitos
EMOJI_RARITY = {
    "Comum": "‚ö™",
    "Rara": "üîµ",
    "√âpica": "üü£",
    "Lend√°ria": "üåü"
}

# Lista de cartas
cartas = {
    "Comum": [
        {"nome": "andryw", "imagem": "imagens/ANDRYW_RUHAN.jpeg", "ataque": 500, "vida": -500},
        {"nome": "√â MAFIA FAMILIA", "imagem": "imagens/MAFIA.PNG", "ataque": 500, "vida": 1000},
        {"nome": "EVOLUCAO", "imagem": "imagens/EVOLUCAO.PNG", "ataque": 666, "vida": 999},
        {"nome": "BOT DJ CLEITON RASTA", "imagem": "imagens/CLEITONRASTA.png", "ataque": 0, "vida": 0},
        {"nome": "PUNHETA√áO", "imagem": "imagens/HORADOPUNHETAO.png"}
    ],
    "Rara": [
        {"nome": "DOUTOR BUGIGANGA", "imagem": "imagens/DOUTORBUGIGANGA.png", "ataque": 1000, "vida": 1500},
        {"nome": "BERINHEAD", "imagem": "imagens/cabecao.jpg", "ataque": 899, "vida": 0},
        {"nome": "VEIO DA CORONA", "imagem": "imagens/veiodacorona.png", "ataque": 500, "vida": 2100}
    ],
    "√âpica": [
        {"nome": "ROGERIO", "imagem": "imagens/ROGERIO.jpg", "ataque": 2000, "vida": 2000},
        {"nome": "CHIQUINHA CABELUDA", "imagem": "imagens/chiquinha.png", "ataque": 250, "vida": 4000},
        {"nome": "NOIA DO K9", "imagem": "imagens/noiak9.png"}
        
    ],
    "Lend√°ria": [
        {"nome": "NARUTO MACONHEIRO", "imagem": "imagens/NARUTOMACONHEIRO.png", "ataque": 2100, "vida": 1800},
        {"nome": "CR7 AURA+EGO", "imagem": "imagens/cr7.png", "ataque": 3500, "vida": 0}
    ]
}


# Sorteio de carta
def sortear_carta():
    sorteio = random.random()
    probabilidade_acumulada = 0
    for raridade, probabilidade in raridades.items():
        probabilidade_acumulada += probabilidade
        if sorteio <= probabilidade_acumulada:
            carta = random.choice(cartas[raridade])
            return carta, raridade
    return None, None


# üî• SUPORTE TOTAL PARA IMAGENS LOCAIS + URL
async def enviar_embed_com_imagem(ctx, embed, imagem):
    if imagem.startswith("http"):
        embed.set_image(url=imagem)
        return await ctx.send(embed=embed)

    else:
        try:
            file = discord.File(imagem, filename=os.path.basename(imagem))
            embed.set_image(url=f"attachment://{os.path.basename(imagem)}")
            return await ctx.send(embed=embed, file=file)
        except Exception as e:
            embed.add_field(name="‚ö† Erro", value=f"Imagem local n√£o encontrada:\n`{imagem}`")
            return await ctx.send(embed=embed)


async def paginate_embeds(ctx, embed_items, timeout: int = 120):
    """Mostra uma lista de (embed, imagem) paginados usando rea√ß√µes.

    Este modo reenvia mensagens a cada mudan√ßa de p√°gina, permitindo o envio de attachments
    (imagens locais) usando `enviar_embed_com_imagem`.
    """
    if not embed_items:
        return

    current = 0

    first_embed, first_image = embed_items[current]
    # envia a primeira p√°gina (usa helper que retorna a mensagem)
    if isinstance(first_image, str) and first_image.startswith(("http://", "https://")):
        message = await ctx.send(embed=first_embed)
    else:
        message = await enviar_embed_com_imagem(ctx, first_embed, first_image)

    if len(embed_items) == 1:
        return

    LEFT = "‚¨ÖÔ∏è"
    RIGHT = "‚û°Ô∏è"
    STOP = "‚èπÔ∏è"

    async def add_nav_reactions(msg):
        for emoji in (LEFT, RIGHT, STOP):
            try:
                await msg.add_reaction(emoji)
            except Exception:
                pass

    await add_nav_reactions(message)

    def check(reaction, user):
        return user == ctx.author and reaction.message.id == message.id and str(reaction.emoji) in (LEFT, RIGHT, STOP)

    while True:
        try:
            reaction, user = await bot.wait_for("reaction_add", timeout=timeout, check=check)
        except Exception:
            # timeout ‚Äî tentar deletar a mensagem de pagina√ß√£o
            try:
                await message.delete()
            except Exception:
                pass
            break

        emoji = str(reaction.emoji)
        try:
            await message.remove_reaction(reaction.emoji, user)
        except Exception:
            pass

        if emoji == STOP:
            try:
                await message.delete()
            except Exception:
                pass
            break

        if emoji == RIGHT:
            current = (current + 1) % len(embed_items)
        elif emoji == LEFT:
            current = (current - 1) % len(embed_items)

        # deleta mensagem antiga para evitar polui√ß√£o
        try:
            await message.delete()
        except Exception:
            pass

        next_embed, next_image = embed_items[current]
        if isinstance(next_image, str) and next_image.startswith(("http://", "https://")):
            message = await ctx.send(embed=next_embed)
        else:
            message = await enviar_embed_com_imagem(ctx, next_embed, next_image)

        # adiciona rea√ß√µes √† nova mensagem
        await add_nav_reactions(message)


# Comando abrir pack
@bot.command()
async def abrirpack(ctx):
    user_id = str(ctx.author.id)
    COST = 50

    # verifica saldo
    if not deduct_balance(user_id, COST):
        saldo = get_balance(user_id)
        await ctx.send(f"{ctx.author.mention} Saldo insuficiente üòî. Voc√™ precisa de {COST} moedas. Saldo: {saldo} ü™ô.")
        return

    carta, raridade = sortear_carta()

    if not carta:
        return await ctx.send("Erro ao sortear carta.")

    imagem = carta["imagem"]

    # embed base (formata√ß√£o mais bonita com emojis)
    nome_card = carta.get('nome', 'Desconhecida')
    atk_val = carta.get('ataque', '‚Äî')
    vida_val = carta.get('vida', '‚Äî')
    emoji = EMOJI_RARITY.get(raridade, '')
    embed = discord.Embed(
        title=f"{emoji} {nome_card} ‚Ä¢ {raridade}",
        description=(
            f"**Nome:** {nome_card}\n"
            f"‚öîÔ∏è **Ataque:** {atk_val}    ‚ù§Ô∏è **Vida:** {vida_val}"
        ),
        color=discord.Color.blue()
    )

    # Duplicada
    if card_already_exists(user_id, carta, raridade):
        add_balance(user_id, 32)
        # embed especial para duplicata
        dup_emoji = EMOJI_RARITY.get(raridade, '')
        embed_dup = discord.Embed(
            title=f"{dup_emoji} Carta Duplicada ‚Ä¢ {raridade} üîÑ",
            description=(
                f"**Nome:** {nome_card}\n"
                f"{ctx.author.mention} Voc√™ j√° possui esta carta!\n\nüéÅ **B√¥nus:** +32 moedas"
            ),
            color=discord.Color.gold()
        )
        await enviar_embed_com_imagem(ctx, embed_dup, imagem)
        saldo_atual = get_balance(user_id)
        await ctx.send(f"{ctx.author.mention} Saldo atual: {saldo_atual} moedas ü™ô.")
        return

    # Nova carta
    add_card_to_user(user_id, carta, raridade)
    await enviar_embed_com_imagem(ctx, embed, imagem)
    saldo = get_balance(user_id)
    await ctx.send(f"Carta adicionada! Saldo atual: {saldo} moedas ü™ô.")


@bot.event
async def on_ready():
    print(f"{bot.user} est√° online!")
    # marca membros existentes (inicia a contagem a partir de agora)
    try:
        if not hasattr(bot, "join_times_marked"):
            # marca todos os membros atuais como tendo entrado agora, se n√£o tiverem timestamp
            data = _load_join_times()
            now = time.time()
            changed = False
            for guild in bot.guilds:
                gid = str(guild.id)
                if gid not in data:
                    data[gid] = {}
                for member in guild.members:
                    if member.bot:
                        continue
                    uid = str(member.id)
                    if uid not in data[gid]:
                        data[gid][uid] = now
                        changed = True
            if changed:
                _save_join_times(data)
            bot.join_times_marked = True
    except Exception:
        pass

    # inicia tarefa de verifica√ß√£o de recompensas por tempo de perman√™ncia
    if not hasattr(bot, "join_awards_task"):
        bot.join_awards_task = asyncio.create_task(_process_join_awards())


@bot.event
async def on_member_join(member):
    # registra o timestamp de entrada para o usu√°rio neste servidor (guild)
    try:
        data = _load_join_times()
        gid = str(member.guild.id)
        uid = str(member.id)
        if gid not in data:
            data[gid] = {}
        data[gid][uid] = time.time()
        _save_join_times(data)
    except Exception:
        pass


async def _process_join_awards():
    """Loop em background que verifica usu√°rios que ficaram >= 30 min no servidor e concede 100 moedas."""
    CHECK_INTERVAL = 60  # segundos
    AWARD_SECONDS = 60 * 30  # 30 minutos
    while True:
        try:
            now = time.time()
            data = _load_join_times()
            changed = False
            for gid, users in list(data.items()):
                guild = bot.get_guild(int(gid))
                if guild is None:
                    # servidor n√£o acess√≠vel ‚Äî remover entradas
                    del data[gid]
                    changed = True
                    continue
                for uid, ts in list(users.items()):
                    try:
                        if now - float(ts) >= AWARD_SECONDS:
                            member = guild.get_member(int(uid))
                            if member is None:
                                # usu√°rio saiu antes de completar 30min
                                del data[gid][uid]
                                changed = True
                                continue
                            # concede 100 moedas
                            add_balance(uid, 100)
                            # tenta avisar o usu√°rio por DM
                            try:
                                await member.send("Parab√©ns ‚Äî voc√™ recebeu 100 moedas por ficar 30 minutos no servidor!")
                            except Exception:
                                pass
                            # atualiza o timestamp para come√ßar nova contagem (permite pr√™mio repetido a cada 30min)
                            data[gid][uid] = now
                            changed = True
                    except Exception:
                        # remove entradas inv√°lidas
                        try:
                            del data[gid][uid]
                            changed = True
                        except Exception:
                            pass
                # se nenhum usu√°rio remanescente, remova o guild key
                if gid in data and not data[gid]:
                    del data[gid]
                    changed = True
            if changed:
                _save_join_times(data)
        except Exception:
            pass
        await asyncio.sleep(CHECK_INTERVAL)

@bot.command()
async def kitdiario(ctx):
    """Reclama o kit di√°rio: 100 moedas a cada 24 horas."""
    user_id = str(ctx.author.id)
    COINS = 125
    can_claim, wait = can_claim_daily(user_id)
    if not can_claim:
        # calcula horas/minutos restantes
        hrs = wait // 3600
        mins = (wait % 3600) // 60
        secs = wait % 60
        await ctx.send(f"{ctx.author.mention} Voc√™ j√° reivindicou o kit di√°rio!. Aguarde {hrs}h {mins}m {secs}s para reclamar novamente üòî.")
        return

    add_balance(user_id, COINS)
    set_claim_time(user_id)
    saldo = get_balance(user_id)
    await ctx.send(f"{ctx.author.mention} Voc√™ recebeu {COINS} moedas do kit di√°rio! Saldo atual: {saldo} ü™ô.")


@bot.command()
async def minhacolecao(ctx):
    """Mostra as cartas que o usu√°rio possui, agrupadas por nome."""
    user_id = str(ctx.author.id)
    cards = get_user_cards(user_id)
    if not cards:
        await ctx.send(f"{ctx.author.mention} Voc√™ ainda n√£o possui cartas em sua cole√ß√£o.")
        return

    # contar por nome
    counts = {}
    for c in cards:
        nome = c.get("nome", "Desconhecida")
        counts[nome] = counts.get(nome, 0) + 1

    lines = [f"{nome} x{qt}" for nome, qt in counts.items()]
    # se a lista for muito grande, dividir em v√°rias mensagens
    chunk_size = 30
    for i in range(0, len(lines), chunk_size):
        chunk = lines[i:i+chunk_size]
        await ctx.send(f"{ctx.author.mention} Sua cole√ß√£o:\n" + "\n".join(chunk))
        

@bot.command()
async def meuscards(ctx):
    """Mostra as cartas que o usu√°rio possui em detalhe (embed por carta)."""
    user_id = str(ctx.author.id)
    cards = get_user_cards(user_id)
    if not cards:
        await ctx.send(f"{ctx.author.mention} Voc√™ ainda n√£o possui cartas em sua cole√ß√£o.")
        return

    def rarity_color(r):
        return {
            "Comum": discord.Color.light_grey(),
            "Rara": discord.Color.blue(),
            "√âpica": discord.Color.purple(),
            "Lend√°ria": discord.Color.gold()
        }.get(r, discord.Color.default())

    # Pagina√ß√£o: mostra 1 carta por p√°gina (embed com imagem se for URL HTTP)
    embed_items = []
    for c in cards:
        nome = c.get("nome", "Desconhecida")
        rar = c.get("raridade", "Desconhecida")
        atk = c.get("ataque", "-")
        vida = c.get("vida", "-")
        imagem = c.get("imagem")

        # embed formatado com emojis
        emoji = EMOJI_RARITY.get(rar, '')
        embed = discord.Embed(
            title=f"{emoji} {nome} ‚Ä¢ {rar}",
            description=f"‚öîÔ∏è **Ataque:** {atk}\n‚ù§Ô∏è **Vida:** {vida}",
            color=rarity_color(rar)
        )

        # Se for URL http/https, define imagem no embed; se for local, mostra somente o nome do arquivo
        if isinstance(imagem, str) and imagem.startswith(("http://", "https://")):
            embed.set_image(url=imagem)
        else:
            if isinstance(imagem, str):
                embed.set_footer(text=f"Imagem local: {os.path.basename(imagem)}")

        # adiciona tupla (embed, imagem) para pagina√ß√£o que reenviar√° mensagens conforme necess√°rio
        embed_items.append((embed, imagem))

    # usa helper de pagina√ß√£o (reutiliz√°vel) que reenvia mensagens com attachments
    await paginate_embeds(ctx, embed_items)

        
@bot.command()
async def saldo(ctx):
    """Mostra o saldo atual do usu√°rio."""
    user_id = str(ctx.author.id)
    saldo_atual = get_balance(user_id)
    await ctx.send(f"{ctx.author.mention}, seu saldo atual √©: {saldo_atual} moedas ü™ô.")

bot.run("MTQ0ODAyNjMyMTEzNjUyMTM4Nw.G2QKUx.S4elqbsZ5LQ-hjTy9EaTc6Boxk0ta42jK7zGsg")
